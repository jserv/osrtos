---
title: u8g2
slug: u8g2
summary: U8g2 is a comprehensive monochrome graphics library for embedded systems,
  designed to support a vast array of OLED and LCD controllers. It provides a flexible
  dual-library approach, offering U8g2 for full graphical rendering and font support,
  and U8x8 for memory-efficient, direct-to-display text output.
codeUrl: https://github.com/olikraus/u8g2
star: 6233
version: 2.29.11
lastUpdated: '2026-01-16'
components:
- Graphics
- GUI
- Shell
platforms:
- AVR
- AVR8
- ARM
- ARM Cortex-M
- Xtensa
- RISC-V
- Linux
- Windows
- macOS
- Native
- POSIX
licenses:
- Unknown
libraryType: Graphics
createdAt: '2025-11-09'
updatedAt: '2026-02-03'
---

### Features


- Support for a wide range of monochrome display controllers including SSD, SH, ST, UC, and IST series.

- Dual-mode operation: U8g2 (full graphics) and U8x8 (text-only, direct-to-display).

- Memory-optimized rendering using 1-page, 2-page, or full-frame buffer configurations.

- Extensive font support with virtually no restriction on font height.

- Comprehensive graphics primitives for drawing lines, boxes, circles, and frames.

- Multiple communication protocol support: 3-wire/4-wire SPI, I2C (Hardware and Software), and 8-bit parallel (6800/8080).

- Software-based display rotation for 0, 90, 180, and 270 degrees, plus mirroring support.

- MUI (Minimal User Interface) subsystem for creating interactive menus and forms.

- U8log component for emulating a serial terminal output on the display.

- 16-bit coordinate mode support for displays exceeding 240x240 pixel dimensions.

- Support for specialized display technologies including E-Ink and VFD controllers.

- Dynamic memory allocation options for page buffers to optimize RAM usage.

- Integrated icon and symbol font libraries.

- Tile-based coordinate system in U8x8 mode for extreme memory efficiency.

- Hardware I2C pin remapping support for compatible microcontroller architectures.



### Architecture

U8g2 is designed with a layered architecture that balances hardware abstraction with graphical flexibility. At the lowest level, the library interacts with display hardware through specific communication drivers (SPI, I2C, or Parallel). The **U8x8** sub-library serves as the foundational layer, providing a direct-to-display interface that operates on 8x8 pixel tiles. This layer requires no RAM buffer in the microcontroller, making it suitable for the most resource-constrained environments.

Sitting above the hardware abstraction is the **U8g2** graphics engine. This layer manages the rendering pipeline and provides the API for drawing primitives and complex fonts. A core architectural feature is the **Page Buffer** mechanism. To support high-resolution displays on microcontrollers with limited RAM, U8g2 can render the screen in horizontal slices (pages). The application uses a `firstPage()`/`nextPage()` loop to redraw the scene for each slice, which the library then transfers to the display controller. This allows for full graphical support even when the MCU cannot hold a complete frame buffer in memory.

### Use Cases

This library is ideal for:

- **Industrial Monitoring**: Displaying real-time sensor data, telemetry, and diagnostic information on ruggedized monochrome LCDs.
- **User Interfaces**: Building interactive menus, settings screens, and forms using the MUI (Minimal User Interface) module.
- **Portable Instrumentation**: Implementing low-power visual feedback for handheld devices like multimeters, environmental sensors, or testers.
- **System Logging**: Utilizing the U8log component to create an on-screen terminal for real-time debugging without requiring a secondary PC connection.
- **Battery-Powered Devices**: Leveraging U8x8 mode to minimize CPU cycles and RAM usage, thereby extending the battery life of wearable or remote hardware.
- **Retro Gaming and Hobbyist Projects**: Rendering simple sprites and graphics on accessible platforms like Arduino, ESP32, and STM32.

### Getting Started

To begin developing with U8g2, users should first identify their display controller and the desired communication interface. In the Arduino IDE, the library can be installed via the Library Manager. The setup process involves selecting a specific **Constructor** that matches the hardware; this constructor defines the controller type, the buffer strategy (Full, 1-page, or 2-page), and the physical pin connections. 

Once the constructor is defined, the `u8g2.begin()` function initializes the display and sends the required setup sequence. Drawing operations are typically performed within a `do...while` loop using `u8g2.firstPage()` and `u8g2.nextPage()`. For developers working in pure C or porting to new platforms, the library provides a specific C-API and documentation for implementing custom hardware abstraction layers. Detailed reference manuals and setup guides for various controllers can be found in the [official Wiki](https://github.com/olikraus/u8g2/wiki).
