---
title: sqlite
slug: sqlite
summary: SQLite is a C-language library that implements a small, fast, self-contained,
  high-reliability, and full-featured SQL database engine. It functions as a serverless,
  zero-configuration database that compiles SQL statements into bytecode for execution
  on a custom virtual machine, making it the most widely deployed database engine
  in the world.
codeUrl: https://github.com/sqlite/sqlite
siteUrl: https://sqlite.org/
star: 8919
version: vesion-3.45.1
lastUpdated: '2026-01-23'
components:
- Database
- FileSystem
- Storage
- Shell
platforms:
- ARM
- x86
- x86_64
- Linux
- Windows
- macOS
- POSIX
- Native
licenses:
- Public Domain
libraryType: Database
createdAt: '2025-12-24'
updatedAt: '2026-01-23'
---

### Features


- Public domain source code allowing for unrestricted use, modification, and distribution.

- Modular architecture separating the SQL compiler front-end from the B-Tree and Pager back-end.

- Virtual Database Engine (VDBE) that executes prepared SQL statements as bytecode for high performance.

- B-Tree storage engine providing ordered key/data storage for tables and indices within a single disk file.

- Pager module implementing atomic transactions, rollback, and recovery via journals or Write-Ahead Logs (WAL).

- Pluggable Virtual File System (VFS) layer to abstract operating system-specific file I/O and locking.

- Lemon parser generator for creating a reentrant, thread-safe, and memory-efficient SQL parser.

- Amalgamation build option that combines the entire library into a single C file for maximum compiler optimization.

- Support for Full-Text Search (FTS5) and R-Tree spatial indexing extensions for advanced querying.

- Atomic commit and rollback mechanisms that ensure data integrity during power failures or system crashes.

- Zero-configuration design requiring no server process, setup, or administrative overhead.

- Cross-platform compatibility with stable, well-defined file formats guaranteed to be compatible moving forward.

- Extensive testing infrastructure including TCL-based test suites, valgrind analysis, and fuzz testing.

- Support for WITHOUT ROWID tables to optimize storage for tables with specific primary key requirements.

- Built-in JSON functions and operators for handling semi-structured data within relational tables.



### Architecture

SQLite employs a highly modular, layered architecture designed to transform SQL text into efficient database operations. The process begins at the **Interface**, where C-language APIs receive SQL queries. These queries pass through a **Tokenizer** and a **Parser** (generated by the Lemon parser generator) to create a parse tree. The **Code Generator** then analyzes this tree to produce bytecode, which is stored in a prepared statement object. This bytecode is executed by the **Virtual Database Engine (VDBE)**, a custom virtual machine that serves as the heart of SQLite's internal logic.

The backend of the library manages data persistence and concurrency. The **B-Tree** layer organizes data into pages and maintains indices for rapid retrieval. Below the B-Tree, the **Pager** module handles the complexities of atomic commits, locking, and caching, utilizing either a rollback journal or a Write-Ahead Log (WAL) to ensure ACID compliance. Finally, the **Virtual File System (VFS)** provides an abstraction layer that allows SQLite to interact with different operating systems (such as Unix or Windows) through a standardized interface for file I/O and time acquisition.

#### Core Components
- **SQL Compiler**: Includes the Tokenizer, Parser, and Code Generator for bytecode production.
- **VDBE**: The bytecode engine that executes prepared statements.
- **B-Tree**: The storage engine managing tables and indices.
- **Pager**: The module responsible for transactions and page-level caching.
- **VFS**: The OS abstraction layer for portability.

### Use Cases

This library is ideal for:

- **Embedded Devices**: Providing a robust database for IoT devices, mobile phones, and automotive systems where resources are constrained.
- **Application File Format**: Serving as a high-performance, cross-platform alternative to custom XML, JSON, or binary file formats for desktop applications.
- **Websites**: Powering low-to-medium traffic websites where a serverless architecture simplifies deployment and maintenance.
- **Data Analysis**: Acting as a temporary engine for processing large datasets or as an intermediate format for data science workflows.
- **Edge Computing**: Storing and synchronizing data at the edge before uploading to a centralized cloud database.

### Getting Started

Developers can integrate SQLite by either using the **Amalgamation** (a single `sqlite3.c` and `sqlite3.h` file pair) or by linking against a precompiled library. The amalgamation is the recommended method as it allows the C compiler to perform cross-procedure optimizations, resulting in a 5% performance boost. To begin, include `sqlite3.h` in your project and use `sqlite3_open()` to initialize a database connection. SQL statements are typically executed using the `sqlite3_prepare_v2()`, `sqlite3_step()`, and `sqlite3_finalize()` workflow. For testing and quick prototyping, the provided Command Line Interface (CLI) shell allows for direct interaction with database files. Detailed API specifications and architectural overviews are available at the official [SQLite documentation](https://sqlite.org/docs.html).
