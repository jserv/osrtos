---
title: DebounceIn
summary: DebounceIn is a specialized C++ library for Mbed OS designed to provide debounced
  interrupt handling for digital inputs. It allows developers to attach ISR-safe callbacks
  to input transitions, ensuring reliable switch and button state detection without
  the noise of mechanical bouncing.
codeUrl: https://github.com/pilotak/DebounceIn
isShow: false
rtos: mbed-os
libraries: []
topics:
- debounce
- debounce-button
- debounce-switch
- input-validation
- mbed
- mbed-os
star: 3
lastUpdated: '2021-06-10'
createdAt: '2025-12-27'
updatedAt: '2025-12-27'
---

In the world of embedded systems, mechanical switches and buttons are notorious for a phenomenon known as "bouncing." When a physical contact is made or broken, it doesn't transition cleanly between high and low states; instead, it oscillates rapidly for a few milliseconds. For an interrupt-driven system, this can trigger dozens of false events for a single press. **DebounceIn** is a lightweight library for the Mbed OS ecosystem that solves this problem by providing a debounced version of the standard `InterruptIn` class.

### Reliable Interrupt Handling

The core purpose of DebounceIn is to filter out the noise generated by mechanical contacts while still leveraging the efficiency of hardware interrupts. Unlike simple polling methods that might block the CPU or miss fast transitions, DebounceIn uses Mbed's interrupt capabilities to detect changes and then applies a debouncing logic to ensure that only valid state changes trigger user-defined callbacks.

One critical aspect of this library is that the attached callbacks are executed within an **Interrupt Service Routine (ISR)** context. This means that any code placed within the `rise` or `fall` callbacks must be non-blocking and efficient. Developers should avoid long-running loops, complex calculations, or I/O operations like `printf` (though it is often used in examples for clarity) inside these handlers to maintain system stability.

### Integration and Usage

Using DebounceIn is straightforward for anyone familiar with the standard Mbed API. It mirrors the interface of `InterruptIn`, making it a drop-in replacement for many use cases. You simply define the pin, attach your callbacks for rising and falling edges, and the library handles the timing and state verification internally.

Here is a typical example of how to implement a debounced button using this library:

```cpp
#include "mbed.h"
#include "DebounceIn.h"

// Initialize the debounced input on a specific pin
DebounceIn button(PE_3);

void buttonRise(){
    // This code runs when the button is released (rising edge)
    // Note: Keep ISR code short and non-blocking
}

void buttonFall(){
    // This code runs when the button is pressed (falling edge)
}

int main() {
    // Attach callbacks to the rise and fall events
    button.rise(callback(buttonRise));
    button.fall(callback(buttonFall));

    // You can also read the current debounced state directly
    bool current_state = button;

    while (1) {
        // Main loop remains free for other tasks
    }
}
```

### Technical Considerations

Because DebounceIn is built specifically for Mbed, it integrates seamlessly with the Mbed OS event model. It is particularly useful in low-power applications where you want the MCU to sleep and only wake up on a valid, debounced external trigger. By handling the debounce logic at the driver level, the application layer remains clean and focused on business logic rather than signal conditioning.

Whether you are building a simple handheld device or a complex industrial controller, handling user input reliably is a fundamental requirement. DebounceIn provides a robust, interrupt-safe foundation for capturing those inputs accurately every time.
