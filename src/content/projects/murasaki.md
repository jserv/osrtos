---
title: Murasaki
summary: A C++ class library for STM32Cube HAL that provides a thread-safe, multi-task
  aware abstraction layer for FreeRTOS environments. It simplifies peripheral control
  using interrupt and DMA-based transfers for UART, SPI, I2C, and audio interfaces
  across various STM32 microcontrollers.
slug: murasaki
codeUrl: https://github.com/suikan4github/murasaki
star: 22
version: v4.0.0
lastUpdated: '2023-07-09'
rtos: freertos
topics:
- cubemx
- freertos
- murasaki
- stm32
- stm32cube
isShow: false
createdAt: '2025-12-31'
updatedAt: '2025-12-31'
---

## Overview

Murasaki is a C++ class library designed to simplify the development of embedded applications on STM32 microcontrollers. While the STM32Cube HAL provides a comprehensive set of drivers, using them effectively within a multi-tasking RTOS environment often requires significant boilerplate code to ensure thread safety and efficient CPU utilization. Murasaki bridges this gap by providing a high-level, object-oriented abstraction layer specifically tailored for FreeRTOS.

By encapsulating the complexities of DMA and interrupt-driven communication, Murasaki allows developers to write clean, synchronous-looking code that remains non-blocking at the system level. This approach ensures that while one task waits for an I/O operation to complete, the RTOS can switch to other tasks, maximizing the efficiency of the Cortex-M processor.

## Key Features and Capabilities

The library provides abstractions for a wide range of standard peripherals, focusing on thread-safe and interrupt-driven operations:

- **Serial Communication**: UART support with a non-blocking, asynchronous `Printf()` function that can be used safely in both task and interrupt contexts.
- **Bus Interfaces**: Master and slave implementations for SPI and I2C.
- **Audio Support**: Abstractions for SAI and I2S, including support for specialized components like the Si5351A PLL.
- **Analog and Digital I/O**: Simplified interfaces for ADC, GPIO, and EXTI (External Interrupts).
- **RTOS Primitives**: Built-in classes for Task management, Synchronizers (Wait-Signal), Critical Sections, and Message output.

## Technical Implementation

Murasaki is built on three core principles: thread safety, interrupt/DMA-based transfers, and blocking I/O. 

In a multi-tasking environment, multiple tasks might attempt to access the same peripheral simultaneously. Murasaki handles this by guarding critical portions of the control program with critical sections, removing the burden of manual mutex management from the programmer. 

To keep the CPU free for other tasks, the library avoids the polling loops often found in standard HAL APIs. Instead, it utilizes DMA and interrupts. When a task initiates a transfer, it enters a blocked state, allowing the RTOS to schedule other work. Once the hardware transfer is complete, an interrupt wakes the task. From the programmer's perspective, the call is a simple blocking function that returns only when the data is ready.

## Hardware Support

The library is tested across a broad spectrum of the STM32 family, including:
- **High Performance**: Nucleo H743ZI, F746ZG, F722ZE, H503RB
- **Mainstream**: Nucleo F446RE, G431RB
- **Ultra-low-power**: Nucleo L412RB-P, L152RE
- **Entry-level**: Nucleo F091RC, G070RB, G0B1RE

## Getting Started

Murasaki is designed as an add-on to the code generated by STM32CubeMX or STM32CubeIDE. After generating a C++ project skeleton, developers can use the provided installation script to integrate the library. This script automates the modification of `main.c` and startup files to hook into the Murasaki platform.

### Code Example: UART Transmission

Transmitting data is straightforward and handles the underlying DMA configuration automatically:

```cpp
uint8_t data[5] = { 1, 2, 3, 4, 5 };
murasaki::UartStatus stat;

// This call blocks the current task until transmission is complete,
// but allows other FreeRTOS tasks to run in the meantime.
stat = murasaki::platform.uart->Transmit(data, 5);
```

### Code Example: I2C Master

Similarly, I2C communication is encapsulated into simple method calls:

```cpp
uint8_t data[5] = { 1, 2, 3, 4, 5 };
murasaki::I2cStatus stat;

stat = murasaki::platform.i2cMaster->Transmit(
                                              127,    // 7-bit slave address
                                              data,   
                                              5);
```

By using Murasaki, developers can leverage the power of the STM32 ecosystem with the productivity of modern C++ and the reliability of a thread-safe RTOS architecture.
