---
title: STM32 Bare-Metal Code Generator
summary: A Python-based utility that automates the generation of bare-metal peripheral
  initialization code for STM32 microcontrollers. It parses official CMSIS device
  headers to produce hardware-level C code for timers, UARTs, ADCs, and GPIO, eliminating
  the overhead of standard HAL libraries.
slug: stm32-bare-metal-code-generator
codeUrl: https://github.com/a5021/stm32codegen
star: 2
lastUpdated: '2025-10-19'
rtos: cmsis
topics:
- cmsis
- code-generator
- stm32
isShow: false
createdAt: '2026-01-04'
updatedAt: '2026-01-04'
---

## Overview

The STM32 Bare-Metal Code Generator (`stm32codegen`) is a specialized Python tool designed for embedded developers who require high-performance, low-overhead initialization code for STM32 microcontrollers. By leveraging the official CMSIS (Cortex Microcontroller Software Interface Standard) header files provided by STMicroelectronics, the tool generates C code that interacts directly with hardware registers. This approach provides a middle ground between the heavy abstraction of the STM32 HAL and the error-prone process of manual register configuration.

## Key Features

The generator is built to be microcontroller-aware, meaning it doesn't rely on hardcoded addresses. Instead, it extracts peripheral configurations and register structures directly from the target device's CMSIS headers. 

**Core capabilities include:**
- **CMSIS-Native Generation**: Produces code using standard CMSIS register definitions, ensuring compatibility with existing ARM development workflows.
- **Multi-Peripheral Support**: Automates setup for critical peripherals including Timers (TIM), UART/USART, Analog-to-Digital Converters (ADC), and General Purpose I/O (GPIO).
- **Flexible Output Modes**: Users can generate isolated code blocks, complete initialization functions, or standalone header files.
- **Broad Device Support**: Compatible with virtually the entire STM32 ecosystem, from the ultra-low-power L0 series to the high-performance H7 series.

## Technical Implementation

The core logic resides in `stm32cgen.py`, which acts as the main generator script. It utilizes a companion module, `stm32cmsis.py`, to parse the complex C header files provided by ST. The generator identifies peripheral base addresses, register offsets, and bitfield masks. 

When a user requests a specific peripheral configuration (e.g., a Timer), the tool generates a C function that sets the appropriate bits in the control registers. Because it uses the CMSIS naming convention (e.g., `TIM1->CR1 |= TIM_CR1_CEN`), the resulting code is highly readable for developers familiar with the STM32 reference manuals.

## Getting Started

The tool is invoked via the command line, making it easy to integrate into automated build systems or Makefiles. A typical command to generate a timer initialization function for an STM32F103 looks like this:

```bash
python stm32cgen.py stm32f103c8 -m tim -f init_tim -p TIM
```

This command instructs the script to look for timer modules (`-m tim`), create a function named `init_tim` (`-f`), and include all TIM peripheral instances found for that specific chip. 

## Integration Example

Once the code is generated, it can be included directly in a bare-metal project. The following example demonstrates how the generated `init_tim()` function fits into a standard main loop:

```c
#include "stm32f1xx.h"  // Standard CMSIS device header

// Generated initialization function
void init_tim(void);

int main(void) {
    // Initialize system clock using standard CMSIS call
    SystemInit();
    
    // Call the code generated by stm32codegen
    init_tim();
    
    while (1) {
        // Application logic here
    }
}
```

## Benefits for Bare-Metal Development

For developers working on resource-constrained devices or applications requiring precise timing, the STM32 Bare-Metal Code Generator offers significant advantages. It eliminates the "black box" nature of the HAL, reduces the binary footprint by avoiding unnecessary library dependencies, and minimizes initialization errors by automating the calculation of register values and bitmasks.
