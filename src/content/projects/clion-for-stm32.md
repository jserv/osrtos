---
title: CLion for STM32
summary: A comprehensive configuration guide and project template for developing STM32
  applications using JetBrains CLion. It leverages the STM32CubeCLT toolchain and
  STM32CubeMX for code generation, providing a modern cross-platform alternative to
  traditional IDEs like Keil with full support for FreeRTOS debugging.
slug: clion-for-stm32
codeUrl: https://github.com/bfmhno3/clion_for_stm32
star: 42
version: v1.1.0
lastUpdated: '2025-10-04'
rtos: freertos
topics:
- c
- clion
- cmake
- cpp
- embedded
- gdb
- j-link
- jetbrain
- openocd
- st-link
- stm32
- stm32cubeclt
- stm32cubemx
- stm32cubeprogrammer
isShow: false
createdAt: '2026-01-12'
updatedAt: '2026-01-12'
---

## Modernizing STM32 Development

For many embedded developers, Keil MDK has been the standard IDE for STM32 development. However, its aging user interface, limited cross-platform support, and sometimes sluggish code completion have led developers to seek more modern alternatives. This project provides a detailed roadmap for transitioning to JetBrains CLion, a powerful cross-platform C/C++ IDE, specifically tailored for the STM32 ecosystem.

Unlike older tutorials that rely on discontinued tools like MinGW, this project utilizes the **STM32CubeCLT** (Command Line Toolset). This official STMicroelectronics package provides a unified set of tools including the ARM GNU toolchain, CMake, Ninja, and STM32CubeProgrammer, ensuring a robust and easily maintainable development environment across Windows and Linux.

## Integrated Workflow and Tooling

The development flow centers around the integration of several key components:

- **STM32CubeMX**: Used for visual pinout configuration, clock tree setup, and peripheral initialization.
- **CLion**: Serves as the primary coding environment, utilizing CMake for build management.
- **OpenOCD & J-Link**: Provides flexible options for flashing and on-chip debugging.
- **STM32CubeCLT**: Supplies the underlying cross-compiler (`arm-none-eabi-gcc`) and build tools.

By using `CMakePresets.json`, the project ensures that build configurations are consistent across different environments, allowing developers to enable specific profiles (like Debug or Release) with a single click within the IDE.

## Advanced Debugging and RTOS Integration

One of the standout features of this setup is its deep integration with **FreeRTOS**. While many IDEs struggle to provide visibility into RTOS task states, CLion offers a dedicated RTOS view. This allows developers to inspect task lists, stack usage, and execution status directly during a debug session.

To enable this, the project highlights the necessity of using a GDB version with Python support. While the standard toolchain's GDB often lacks this, CLion's bundled multi-arch GDB can be configured to bridge this gap, enabling features like:
- Task-aware debugging
- Stack high-water mark tracking
- Queue registry inspection

## Hardware Debugger Flexibility

The guide covers multiple debugging paths, including OpenOCD, STM32CubeProgrammer, and J-Link. A particularly interesting section describes how to convert a standard, low-cost **MINI ST-LINK V2** clone into a **J-Link** probe using SEGGER's ST-Link Reflash utility. This conversion allows developers to use the high-performance J-Link GDB Server and associated software suite on inexpensive hardware, provided the MCU on the clone has sufficient flash memory (such as the APM32 or GD32 variants).

## Getting Started

To use this project as a template, developers should ensure they have CLion 2025.1 or later to take advantage of the latest embedded server features. The repository includes a demo project for the STM32F103C8T6 (Blue Pill) that demonstrates a basic LED blink with HAL. 

Key configuration steps involve:
1. Installing STM32CubeCLT and STM32CubeMX.
2. Configuring the Toolchain in CLion to point to the CLT binaries.
3. Enabling the CMake profiles generated by the `.ioc` file.
4. Setting up the Embedded GDB Server for your specific hardware probe (ST-Link or J-Link).

This setup provides a professional-grade environment that rivals or exceeds traditional embedded IDEs in terms of code navigation, refactoring, and real-time debugging capabilities.
